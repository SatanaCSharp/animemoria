// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.1
//   protoc               v4.25.2
// source: health.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import type {
  handleServerStreamingCall,
  handleUnaryCall,
  Metadata,
  UntypedServiceImplementation,
} from '@grpc/grpc-js';
import { GrpcMethod, GrpcStreamMethod } from '@nestjs/microservices';
import { Observable } from 'rxjs';

export interface HealthCheckRequest {
  /**
   * Service name to check. Empty string "" means overall server health.
   * For per-service checks, use the fully-qualified service name (e.g., "users_service.UsersService").
   */
  service: string;
}

export interface HealthCheckResponse {
  status: HealthCheckResponse_ServingStatus;
}

export enum HealthCheckResponse_ServingStatus {
  UNKNOWN = 0,
  SERVING = 1,
  NOT_SERVING = 2,
  /** SERVICE_UNKNOWN - Used for Watch: service does not exist or is not registered */
  SERVICE_UNKNOWN = 3,
}

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return { service: '' };
}

export const HealthCheckRequest: MessageFns<HealthCheckRequest> = {
  encode(
    message: HealthCheckRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.service !== '') {
      writer.uint32(10).string(message.service);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): HealthCheckRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.service = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { status: 0 };
}

export const HealthCheckResponse: MessageFns<HealthCheckResponse> = {
  encode(
    message: HealthCheckResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): HealthCheckResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

/**
 * Standard gRPC health checking protocol.
 * @see https://github.com/grpc/grpc/blob/master/doc/health-checking.md
 */

export interface HealthClient {
  /**
   * Synchronous health check. Returns the current health status.
   * Use empty service name "" for overall server health.
   */

  check(
    request: HealthCheckRequest,
    metadata?: Metadata,
  ): Observable<HealthCheckResponse>;

  /**
   * Streaming health check. Server sends updates when status changes.
   * Useful for load balancers that need real-time health updates.
   */

  watch(
    request: HealthCheckRequest,
    metadata?: Metadata,
  ): Observable<HealthCheckResponse>;
}

/**
 * Standard gRPC health checking protocol.
 * @see https://github.com/grpc/grpc/blob/master/doc/health-checking.md
 */

export interface HealthController {
  /**
   * Synchronous health check. Returns the current health status.
   * Use empty service name "" for overall server health.
   */

  check(
    request: HealthCheckRequest,
    metadata?: Metadata,
  ):
    | Promise<HealthCheckResponse>
    | Observable<HealthCheckResponse>
    | HealthCheckResponse;

  /**
   * Streaming health check. Server sends updates when status changes.
   * Useful for load balancers that need real-time health updates.
   */

  watch(
    request: HealthCheckRequest,
    metadata?: Metadata,
  ): Observable<HealthCheckResponse>;
}

export function HealthControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ['check', 'watch'];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(
        constructor.prototype,
        method,
      );
      GrpcMethod('Health', method)(
        constructor.prototype[method],
        method,
        descriptor,
      );
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(
        constructor.prototype,
        method,
      );
      GrpcStreamMethod('Health', method)(
        constructor.prototype[method],
        method,
        descriptor,
      );
    }
  };
}

export const HEALTH_SERVICE_NAME = 'Health';

/**
 * Standard gRPC health checking protocol.
 * @see https://github.com/grpc/grpc/blob/master/doc/health-checking.md
 */
export type HealthService = typeof HealthService;
export const HealthService = {
  /**
   * Synchronous health check. Returns the current health status.
   * Use empty service name "" for overall server health.
   */
  check: {
    path: '/grpc.health.v1.Health/Check',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HealthCheckRequest): Buffer =>
      Buffer.from(HealthCheckRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): HealthCheckRequest =>
      HealthCheckRequest.decode(value),
    responseSerialize: (value: HealthCheckResponse): Buffer =>
      Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): HealthCheckResponse =>
      HealthCheckResponse.decode(value),
  },
  /**
   * Streaming health check. Server sends updates when status changes.
   * Useful for load balancers that need real-time health updates.
   */
  watch: {
    path: '/grpc.health.v1.Health/Watch',
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: HealthCheckRequest): Buffer =>
      Buffer.from(HealthCheckRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): HealthCheckRequest =>
      HealthCheckRequest.decode(value),
    responseSerialize: (value: HealthCheckResponse): Buffer =>
      Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): HealthCheckResponse =>
      HealthCheckResponse.decode(value),
  },
} as const;

export interface HealthServer extends UntypedServiceImplementation {
  /**
   * Synchronous health check. Returns the current health status.
   * Use empty service name "" for overall server health.
   */
  check: handleUnaryCall<HealthCheckRequest, HealthCheckResponse>;
  /**
   * Streaming health check. Server sends updates when status changes.
   * Useful for load balancers that need real-time health updates.
   */
  watch: handleServerStreamingCall<HealthCheckRequest, HealthCheckResponse>;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
