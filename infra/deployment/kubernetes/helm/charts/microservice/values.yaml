# Default values for the universal microservice chart.
# Override per service via -f values/<service>.yaml
# Use -f values/cluster.yaml (or global -f) for imageRepository and cluster.knownServices.

nameOverride: ""
fullnameOverride: ""

# Image: repository is taken from imageRepository (or global) when not set here.
# Set only image.name (and optionally tag); repository is centralized.
imageRepository: ""  # e.g. my-registry.io/my-repo — set via -f values/cluster.yaml or --set
image:
  repository: ""     # override per release; default: imageRepository
  name: app-name     # e.g. registry-service, users-service
  tag: latest
  pullPolicy: Always
  pullSecrets: []    # optional, e.g. [name: regcred]

# Override container CMD for variants (e.g. ["node", "dist/grpc.main"])
command: []  # e.g. ["node", "dist/grpc.main"] or leave [] for default

# InitContainer: wait for these services. Port is resolved from cluster.knownServices when omitted.
# Each entry: service (K8s Service DNS name) and optional port (fallback if not in knownServices).
dependencies: []     # e.g. [ { service: registry }, { service: users-grpc } ]

# Central map: service fullname (release name) -> port. Used to resolve dependency ports and URLs.
# Set once via -f values/cluster.yaml so per-service values don't repeat ports.
cluster:
  knownServices: {}  # e.g. { "registry": 3000, "users-grpc": 50051, "auth-grpc": 50052, ... }

# Convention over configuration: protocol drives port (http -> 3000/80, grpc -> 5000/5000).
protocol: http  # or grpc
# Optional: override port env key (default: APP_PORT for http, APP_GRPC_PORT for grpc). Set e.g. APP_GRAPHQL_PORT, APP_REST_PORT.
portEnvKey: ""

# Explicit env key-values from values (non-sensitive). Sensitive vars must be in existingSecret.
# Source: apps/<service>/.env.example. Example: [ { name: NODE_ENV, value: "production" }, { name: LOG_LEVEL, value: "info" } ]
env: []

# Required key names in existingSecret (from apps/<service>/.env.example). ESO or manual Secret must provide these.
# Documented per service in values/<service>/*.yaml; used for validation/docs and ESO secret key mapping.
secretKeys: []  # e.g. [ DB_CONNECTION_URL, AT_SECRET, RT_SECRET, INTERNAL_REGISTRY_SERVER_HOST ]

# global-shared-config: non-sensitive env (NODE_ENV, LOG_*). Used by default in deployment envFrom.
# Set create: true on one release (e.g. registry) to create the ConfigMap; others leave false.
sharedConfigMap:
  create: false
  data:
    NODE_ENV: "production"
    LOG_LEVEL: "info"
    LOG_PRETTY: "false"

# Env from Secrets/ConfigMaps — sensitive vars in Secret (default: <fullname>-secrets).
existingSecret: ""   # default: {{ fullname }}-secrets
existingConfigMap: "" # optional, for service-specific non-sensitive config

# Resources
resources:
  requests:
    memory: "128Mi"
    cpu: "100m"
  limits:
    memory: "512Mi"
    cpu: "500m"

# Replicas (ignored when autoscaling.enabled is true)
replicaCount: 1

# Deployment strategy (RollingUpdate or Recreate)
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: "25%"
    maxUnavailable: 0

# Autoscaling (HPA)
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 70

# Pod Disruption Budget (use either minAvailable or maxUnavailable, not both)
pdb:
  enabled: false  # Default to false, enable per-service for HA
  minAvailable: 1 # Ensure at least 1 pod is always up
  # maxUnavailable: 1 # Alternative option (uncomment and remove/zero minAvailable to use)

# Service type only; port/targetPort/name derived from protocol (http -> 80->3000, grpc -> 5000->5000).
service:
  type: ClusterIP

# Pod annotations / labels
podAnnotations: {}
podLabels: {}

# Node selector / tolerations / affinity (optional)
nodeSelector: {}
tolerations: []
affinity: {}
